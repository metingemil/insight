;  EXECUTABLE NAME : XLAT1
;  VERSION         : 1.0
;  CREATED DATE    : 2/11/2009
;  LAST UPDATE     : 2/11/2009
;  AUTHOR          : JEFF DUNTEMANN
;  DESCRIPTION     : A SIMPLE PROGRAM IN ASSEMBLY FOR LINUX, USING NASM 2.05,
;    DEMONSTRATING THE USE OF THE XLAT INSTRUCTION TO ALTER TEXT STREAMS.
;
;  BUILD USING THESE COMMANDS:
;    NASM -F ELF -G -F STABS XLAT1.ASM
;    LD -O XLAT1 XLAT1.O
;

SECTION .DATA			; SECTION CONTAINING INITIALISED DATA
	
	STATMSG: DB "PROCESSING...",10
	STATLEN: EQU $-STATMSG
	DONEMSG: DB "...DONE!",10
	DONELEN: EQU $-DONEMSG
	
; THE FOLLOWING TRANSLATION TABLE TRANSLATES ALL LOWERCASE CHARACTERS TO
; UPPERCASE. IT ALSO TRANSLATES ALL NON-PRINTABLE CHARACTERS TO SPACES,
; EXCEPT FOR LF AND HT.
	UPCASE: 
	DB 20H,20H,20H,20H,20H,20H,20H,20H,20H,09H,0AH,20H,20H,20H,20H,20H
	DB 20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H
	DB 20H,21H,22H,23H,24H,25H,26H,27H,28H,29H,2AH,2BH,2CH,2DH,2EH,2FH
	DB 30H,31H,32H,33H,34H,35H,36H,37H,38H,39H,3AH,3BH,3CH,3DH,3EH,3FH
	DB 40H,41H,42H,43H,44H,45H,46H,47H,48H,49H,4AH,4BH,4CH,4DH,4EH,4FH
	DB 50H,51H,52H,53H,54H,55H,56H,57H,58H,59H,5AH,5BH,5CH,5DH,5EH,5FH
	DB 60H,41H,42H,43H,44H,45H,46H,47H,48H,49H,4AH,4BH,4CH,4DH,4EH,4FH
	DB 50H,51H,52H,53H,54H,55H,56H,57H,58H,59H,5AH,7BH,7CH,7DH,7EH,20H
	DB 20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H
	DB 20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H
	DB 20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H
	DB 20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H
	DB 20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H
	DB 20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H
	DB 20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H
	DB 20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H

; THE FOLLOWING TRANSLATION TABLE IS "STOCK" IN THAT IT TRANSLATES ALL
; PRINTABLE CHARACTERS AS THEMSELVES, AND CONVERTS ALL NON-PRINTABLE
; CHARACTERS TO SPACES EXCEPT FOR LF AND HT. YOU CAN MODIFY THIS TO
; TRANSLATE ANYTHING YOU WANT TO ANY CHARACTER YOU WANT.
	CUSTOM: 
	DB 20H,20H,20H,20H,20H,20H,20H,20H,20H,09H,0AH,20H,20H,20H,20H,20H
	DB 20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H
	DB 20H,21H,22H,23H,24H,25H,26H,27H,28H,29H,2AH,2BH,2CH,2DH,2EH,2FH
	DB 30H,31H,32H,33H,34H,35H,36H,37H,38H,39H,3AH,3BH,3CH,3DH,3EH,3FH
	DB 40H,41H,42H,43H,44H,45H,46H,47H,48H,49H,4AH,4BH,4CH,4DH,4EH,4FH
	DB 50H,51H,52H,53H,54H,55H,56H,57H,58H,59H,5AH,5BH,5CH,5DH,5EH,5FH
	DB 60H,61H,62H,63H,64H,65H,66H,67H,68H,69H,6AH,6BH,6CH,6DH,6EH,6FH
	DB 70H,71H,72H,73H,74H,75H,76H,77H,78H,79H,7AH,7BH,7CH,7DH,7EH,20H
	DB 20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H
	DB 20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H
	DB 20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H
	DB 20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H
	DB 20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H
	DB 20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H
	DB 20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H
	DB 20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H,20H

SECTION .BSS			; SECTION CONTAINING UNINITIALIZED DATA

	READLEN	    EQU 1024		; LENGTH OF BUFFER
	READBUFFER: RESB READLEN	; TEXT BUFFER ITSELF
	
SECTION .TEXT			; SECTION CONTAINING CODE

GLOBAL 	_START			; LINKER NEEDS THIS TO FIND THE ENTRY POINT!
	
_START:
	NOP			; THIS NO-OP KEEPS GDB HAPPY...

; DISPLAY THE "I'M WORKING..." MESSAGE VIA STDERR:
	MOV EAX,4		; SPECIFY SYS_WRITE CALL
	MOV EBX,2		; SPECIFY FILE DESCRIPTOR 2: STANDARD ERROR
	MOV ECX,STATMSG		; PASS OFFSET OF THE MESSAGE
	MOV EDX,STATLEN		; PASS THE LENGTH OF THE MESSAGE
	INT 80H			; MAKE KERNEL CALL

; READ A BUFFER FULL OF TEXT FROM STDIN:
READ:
	MOV EAX,3		; SPECIFY SYS_READ CALL
	MOV EBX,0		; SPECIFY FILE DESCRIPTOR 0: STANDARD INPUT
	MOV ECX,READBUFFER	; PASS OFFSET OF THE BUFFER TO READ TO
	MOV EDX,READLEN		; PASS NUMBER OF BYTES TO READ AT ONE PASS
	INT 80H
	MOV EBP,EAX		; COPY SYS_READ RETURN VALUE FOR SAFEKEEPING
	CMP EAX,0		; IF EAX=0, SYS_READ REACHED EOF
	JE DONE			; JUMP IF EQUAL (TO 0, FROM COMPARE)

; SET UP THE REGISTERS FOR THE TRANSLATE STEP:
	MOV EBX,UPCASE		; PLACE THE OFFSET OF THE TABLE INTO EBX
	MOV EDX,READBUFFER	; PLACE THE OFFSET OF THE BUFFER INTO EDX
	MOV ECX,EBP		; PLACE THE NUMBER OF BYTES IN THE BUFFER INTO ECX

; USE THE XLAT INSTRUCTION TO TRANSLATE THE DATA IN THE BUFFER:
TRANSLATE:
	MOV AL,[EDX+ECX]	; LOAD CHARACTER INTO AL FOR TRANSLATION
	XLAT			; TRANSLATE CHARACTER IN AL VIA TABLE
	MOV [EDX+ECX],AL	; PUT THE TRANSLATED CHARACTER BACK IN THE BUFFER
	DEC ECX			; DECREMENT CHARACTER COUNT
	JNZ TRANSLATE		; IF THERE ARE UNTRANSLATED CHARS IN THE BUFFER, REPEAT

; WRITE THE BUFFER FULL OF TRANSLATED TEXT TO STDOUT:
WRITE:
	MOV EAX,4		; SPECIFY SYS_WRITE CALL
	MOV EBX,1		; SPECIFY FILE DESCRIPTOR 1: STANDARD OUTPUT
	MOV ECX,READBUFFER	; PASS OFFSET OF THE BUFFER
	MOV EDX,EBP		; PASS THE # OF BYTES OF DATA IN THE BUFFER
	INT 80H			; MAKE KERNEL CALL
	JMP READ		; LOOP BACK AND LOAD ANOTHER BUFFER FULL

; DISPLAY THE "I'M DONE" MESSAGE VIA STDERR:
DONE:	
	MOV EAX,4		; SPECIFY SYS_WRITE CALL
	MOV EBX,2		; SPECIFY FILE DESCRIPTOR 2: STANDARD ERROR
	MOV ECX,DONEMSG		; PASS OFFSET OF THE MESSAGE
	MOV EDX,DONELEN		; PASS THE LENGTH OF THE MESSAGE
	INT 80H			; MAKE KERNEL CALL

; ALL DONE! LET'S END THIS PARTY:
	MOV EAX,1		; CODE FOR EXIT SYSCALL
	MOV EBX,0		; RETURN A CODE OF ZERO	
	INT 80H			; MAKE KERNEL CALL
